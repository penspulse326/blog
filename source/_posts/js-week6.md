---
title: "[筆記] 初入 JavaScript 的網路請求"
date: 2023-09-19 14:43:08
tags:
  - JavaScript
  - 程式語言
  - API
categories: 程式學習
---

從串接 API 開始就會有很多五欸ㄇ欸問題發生，
因為在 JS 裡面要處理網路請求就要認識更多相關的函式和系統機制，
這篇來記錄必定會碰到的知識點。

<!-- more -->

## RESTful 不是很放鬆

其實要說放鬆也可以，只要知道這個架構在做什麼，
就會讓規劃變得很輕鬆（並沒有）

REST 其實是指一種網路系統的設計風格，
主要有六種重要的指標：

1. **客戶端-伺服器端**：意指將前後端的程式系統完全分開，方便兩端的功能開發管理與擴充、維護。
2. **無狀態**：客戶端的請求每次都是獨立的，跟上次的請求無關，每次新請求都會得到包含必要資訊的回應。（比如說按電鈴，按幾次就會響幾次，每次的行為都是獨立的）
3. **快取**：可以保留某些請求行為和資源，在有效期限內客戶端如果再發起一樣的請求，可以直接在中間伺服器給出快取的資料，不用每次都與真正的伺服器請求，節省伺服器負載。
4. **統一介面**：這是等等要說的。
5. **分層系統**：前後端中間通常會再安排代理伺服器，用來處理快取、身份驗證、資安等等的一些業務邏輯，減少直接訪問訪問後端伺服器造成的流量消耗和危險性。
6. **按需代碼（可選）**：根據特定的請求從後端生成程式碼，再發送到前端執行。

所以我們經常聽到的 RESTful API 就是建立在以上的概念所設計出來的網路請求方法～

API 最常見的就是使用者透過網址（URL）發送過來的請求，
來對應伺服器要做的事，所以這時候**路由**的設計就很重要，
也就是上面說的統一介面的問題。

前後端的開發人員會規劃出一套完整的路由系統，
讓雙方可以看懂請求的行為是什麼～

比如我們部署了留言板網站的網域 www.our-comments.com 指向我們的伺服器時，
前端會根據畫面的按鈕、表單、超連結等等的互動行為，
**把使用者想做的事透過子網域的 URL 發送過來讓後端接收**，
因此路由可能會這樣設計：

| URL                           | HTTP method | Definition             |
| ----------------------------- | ----------- | ---------------------- |
| /user/:id                     | GET         | 查看某個使用者的資料   |
| /user/:id/comments            | GET         | 查看某個使用者的留言   |
| /user/:id/add                 | POST        | 在某個使用者的頁面留言 |
| /user/:id/comments/:id/update | PUT         | 更新某一則留言         |
| /user/:id/comments/:id/delete | DELETE      | 刪除某一則留言         |

一般我們常使用的網站大多也會設計對應的路由，
所以網址列經常會看到類似的結構！

---

## 等你回來再出發：非同步

同步是指一次能進行幾個任務的概念，
一般高階語言如 Java、Python、C# 等等的，
它們是**多執行緒**的程式語言，因此主程式啟動之後，
它們可以一次執行多個函式甚至是多個獨立的程式碼檔案～

可以想像成在玩 RPG 的時候，身為主角的你正在跑主線劇情，
但同時你能夠僱傭很多工人去跑相關的支線，
因此你在很短的時間內就打完這個遊戲了。

而 JS 是**單執行緒**的程式語言，
這表示 JS 一次只能執行一段程式碼，
也就是在 RPG 的世界裡，你一次只能開一個任務，
慢慢地把主線或支線農完然後結束遊戲......

但這不表示 JS 是廢物，因為上面舉例的多執行緒語言，
其實都和它們出現的年代、被設計用來做什麼 APP 的原因有關。
JS 起初是用來豐富網頁的動態性，所以只能在瀏覽器內跑的程式。
（因此沒辦法做出多執行緒，因為容量太大了）

JS 也透過一些機制，讓它可以把程式執行的過程變成非同步！

---

## Call Me In Your Stack：callback function

callback 就是 JS 一種非同步的機制，
比如 forEach、陣列的 map 方法等等，
可以發現它們在函式內帶入的參數也是一個函式，
這些參數函式就是 callback，它們會被丟到引擎內的容器，
依照後進先出的原則再放進任務排程，（後進先出是資料結構 Stack 的特性，先不探討太深入 QQ）
引擎的執行緒已經沒有任務後就會從排程裡面再取出剛剛被扔進去的 callback ～

這也會探討到一開始在介紹變數宣告的時候為什麼最好少用 var，
因為這些 callback 在後續回到執行緒（全域環境）跑的時候，
var 很容易造成污染，callback 可能也會沒辦法做到想要的事。

---

## 壞男人從不承諾：Promise

JS 變相來說也是個壞男人...
因為這些非同步的機制，它可以把需要等待時間、延後執行的 callback 先打入冷宮，
繼續往下找別的女...阿不，是繼續往下執行別的程式，
因此你可以發現進到購物網站時，有時商品的列表是一片空白還在讀取，
但是點擊網頁其他的地方還是會動作的，因為 JS 可以利用非同步把它們的任務切割。

Promise 在戳 API 這類網路請求的功能時就是經常會用到的方式，
**Promise 簡單地說是一種特別的物件**，內容非同步請求的結果，
請求成功或失敗都會有對應的資料，但是沒辦法直接用 console.log 看到內容，
因此也無法直接取出使用，**需要用後綴 then() 的方式取出資料**。

```JS
function getData(apiUrl) {
  fetch.(apiUrl).then((res) => console.log(res)).catch((error)=>console.log(error))
}
```

在 fetch 方法裡帶入網址後會回傳一個 Promise 物件，
如上面所說，如果我們要取出資料就必須在後面接一個 .then，
.then 裡面的 callback 預設參數就是伺服器回應的資料，
這時才能用 console.log 查看內容，或是用外層的變數儲存起來。

所以一般購物網站的商品列因為圖片和資料屬性比較多，
戳 API 之後把這些資料接收過來到顯示在網頁上是需要一段時間的，
這段過程是在等待伺服器傳回來的資料，並且打包成 Promise 物件再解析出來。

因為非同步的網路請求並不是每次都會成功，有時會遇到伺服器的問題，或是網頁程式的問題，
因此除了 .then() 之外也需要 .catch() 來捕捉錯誤通知，
.catch() 只會在錯誤發生的時候捕捉到，
但要注意的是 .then 裡面也有可能拿到錯誤通知，
所以 .then 與 .catch 都要下才能知道是前後端或資料庫的錯誤訊息！

---

## 一個武器大師：AJAX

(爛梗)

AJAX 簡單地說就是非同步網路請求的技術，
比如 JS 原生的 fetch、或是 axios、jQuery 這類好用的套件都是一種 AJAX 技術。

原生的 fetch 雖然可以直接使用，
不過要寫的東西還有機制就相對複雜一點，
以剛剛的範例來說：

```JS
function getData(apiUrl) {
  fetch.(apiUrl)
    .then((res) => res.json())
    .then((result) => console.log(result))
    .catch((error)=>console.log(error))
}
```

第一個 then 拿到的參數通常不會是結構化的資料，所以要透過內建的 .json() 方法，
再丟出一個 Promise 物件，然後加上第二個 then 取出來...就是這麼麻煩 XD

axios 則簡化了這些流程，從 axios 回傳的 Promise 物件，
只要用一次 then 就可以取出，HTTP method 也可以透過點記法直接叫出對應的方法。

另外 axios 可以在發送請求前就取消，或是對請求做一些格式驗證，
但是 fetch 就沒有內建的方法了，需要自己再額外撰寫。

因為 axios 是外掛上去的模組，
所以不論是前端或 Node.js 之類的 JS 環境都是可以執行的。

---

### 參考資料

- [RESTful API 與 MVC 名詞介紹](https://ithelp.ithome.com.tw/articles/10191925)
- [表現層狀態轉換](https://zh.wikipedia.org/zh-tw/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2)
- [一次搞懂同步與非同步的一切](https://medium.com/itsems-frontend/javascript-sync-async-22e75e1ca1dc)
- [AJAX 完整解說系列：基礎觀念](https://www.casper.tw/development/2020/09/30/about-ajax/)
